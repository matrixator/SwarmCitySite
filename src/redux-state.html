<script src="../node_modules/redux/dist/redux.min.js"></script>
<link rel="import" href="../bower_components/polymer-redux/polymer-redux.html">
<script>
    let publicKey;
    let avatar;
    let username;
    let storage = JSON.parse(localStorage.getItem('SwarmCity'));

    if (storage && storage.keyStore && storage.keyStore.address) {
        publicKey = storage.keyStore.address;
    } else {
        publicKey = '';
    }
    if (storage && storage.user && storage.user.username) {
        username = storage.user.username;
    } else {
        username = '';
    }
    if (storage && storage.user && storage.user.avatar) {
        avatar = storage.user.avatar;
    }

    let initialState = {
        gasPrice: 21e9,
        username: username,
        avatar: avatar,
        language: 'en',
        fx: {
            priceBtc: 1,
            priceEur: 1,
            priceUsd: 1,
        },
        balance: {
            eth: 99,
            swt: 1.75,
            arc: 97,
        },
        reputation: [{
            hashtag: 'Pioneer',
            swr: 11,
            dealsDone: 2,
            dealsConflicted: 1,
        },
        {
            hashtag: 'NeedARide',
            swr: 12,
            dealsDone: 3,
            dealsConflicted: 0,
            address: '0x9258385b6BAd9B1F6d5374B063B8c4B63C5B7191',
        }],
        hashtags: [{
            name: 'Settler',
            address: '0xeba08e7a1d8145b25c78b473fbc35aa24973d908',
            location: '9q8yfr43d4',
            short: 'a23d33',
            stats: {'}paidNoConflict': 230, 'resolved': 23, 'seekers': 224, 'providers': 56},
            description: 'Settler is the first amazing hashtag',
            maintainer: {
                avatar: '[[importPath]]../../images/defaultavatar.png',
                username: 'Piet Snot',
                address: '0x369D787F3EcF4a0e57cDfCFB2Db92134e1982e09',
            },
            hashtagFee: 500000000000000000,
        }, {
            name: 'DevOps',
            address: '0x9258385b6BAd9B1F6d5374B063B8c4B63C5B7191',
            location: '9q8yfr43s4',
            short: 'a23d33',
            stats: {'}paidNoConflict': 69, 'resolved': 23, 'seekers': 42, 'providers': 12},
            description: 'Here users pay developers for platform improvements',
            maintainer: {
                avatar: '[[importPath]]../../images/defaultavatar.png',
                username: 'Mungo Weber',
                address: '0x369D787F3EcF4a0e57cDfCFB2Db92134e1982e09',
            },
            hashtagFee: 500000000000000000,
        }, {
            name: 'NeedARide',
            address: '0x9258385b6BAd9B1F6d5374B063B8c4B63C5B7191',
            location: '9q8yff43d4',
            short: 'a23d33',
            stats: {'}paidNoConflict': 378, 'resolved': 23, 'seekers': 872, 'providers': 235},
            description: 'Ridesharing on the blockchain',
            maintainer: {
                avatar: '[[importPath]]../../images/defaultavatar.png',
                username: 'John Doe',
                address: '0x369D787F3EcF4a0e57cDfCFB2Db92134e1982e09',
            },
            hashtagFee: 500000000000000000,
        },
        ],
        publicKey: publicKey,
        nonce: -1,
    };

    /**
     * Recalculate balances & formatting of
     *
     * @param      {Object}  balance  The balance object
     * @param      {Object}  fx       The fx object ( exchange rates )
     * @return     {Object}  decorated balance object
     */
    function updateBalance(balance, fx) {
        if (balance &&
            balance.swt &&
            balance.swt.balance &&
            fx &&
            fx.priceEur &&
            fx.priceBtc &&
            fx.priceUsd) {
            balance.swt.balanceSwt = (balance.swt.balance / 1e18).toFixed(2);
            balance.swt.balanceEur = (balance.swt.balance / 1e18 * fx.priceEur).toFixed(2);
            balance.swt.balanceBtc = (balance.swt.balance / 1e18 * fx.priceBtc);
            balance.swt.balanceUsd = (balance.swt.balance / 1e18 * fx.priceUsd).toFixed(2);
        }
        if (balance &&
            balance.eth &&
            balance.eth.balance) {
            balance.eth.balanceEth = (balance.eth.balance / 1e18);
        }
        return balance;
    }

    /**
     * safely parse a string to Number. Independent of locale ( , or . )
     *
     * @param      {string}  input   The input
     * @return     {Number}  The floating point value - or 0 if cannot parse
     */
    function _parseFloat(input) {
        if (input && typeof input === 'string') {
            let parsed = Number.parseFloat(input.replace(',', '.'));
            if (Number.isNaN(parsed)) {
                return 0;
            }
            return parsed;
        } else {
            return 0;
        }
    }

    let reducer = function(state, action) {
        if (!state) {
            return initialState;
        }
        switch (action.type) {
            case 'IPHONE': {
                let iphone = state.iphone;
                iphone = action.iphone;
                return Object.assign({}, state, {
                    iphone: iphone,
                });
            }
            case 'SHORTCODE': {
                let shortCode = state.shortCode;
                shortCode = action.shortCode;
                return Object.assign({}, state, {
                    shortCode: shortCode,
                });
            }
            case 'USINGSHORTCODE': {
                let usingShortCode = state.usingShortCode;
                usingShortCode = action.usingShortCode;
                return Object.assign({}, state, {
                    usingShortCode: usingShortCode,
                });
            }
            case 'BALANCE': {
                let balance = state.balance;
                balance = action.balance;
                return Object.assign({}, state, {
                    balance: updateBalance(balance, state.fx),
                });
            }
            case 'FX': {
                let fx = state.fx;
                fx = action.fx;

                // convert strings to Float
                if (fx.priceBtc) fx.priceBtc = _parseFloat(fx.priceBtc);
                if (fx.priceEur) fx.priceEur = _parseFloat(fx.priceEur);
                if (fx.priceUsd) fx.priceUsd = _parseFloat(fx.priceUsd);

                return Object.assign({}, state, {
                    fx: fx,
                    balance: updateBalance(state.balance, fx),
                });
            }
            case 'HASHTAGS': {
                let hashtags = state.hashtags;
                hashtags = action.hashtags;
                return Object.assign({}, state, {
                    hashtags: hashtags,
                });
            }
            case 'LANGUAGE': {
                let language = state.language;
                language = action.language;
                return Object.assign({}, state, {
                    language: language,
                });
            }
            case 'ITEMCOLLECTION': {
                let itemCollection = state.itemCollection;
                itemCollection = action.itemCollection;
                return Object.assign({}, state, {
                    itemCollection: itemCollection,
                });
            }
            case 'LOCATION': {
                let location = state.location;
                location = action.location;
                return Object.assign({}, state, {
                    location: location,
                });
            }
            case 'PUBLICKEY': {
                let publicKey = state.publicKey;
                publicKey = action.publicKey;
                return Object.assign({}, state, {
                    publicKey: publicKey,
                });
            }
            case 'GASPRICE': {
                let gasPrice = state.gasPrice;
                gasPrice = _parseFloat(action.gasPrice);
                return Object.assign({}, state, {
                    gasPrice: gasPrice,
                });
            }
            case 'NONCE': {
                let nonce = state.nonce;
                nonce = action.nonce;
                return Object.assign({}, state, {
                    nonce: nonce,
                });
            }
            // This is the shortCode we want a public key for
            case 'REQTOKEY': {
                let reqtokey = state.reqtokey;
                reqtokey = action.reqtokey;
                return Object.assign({}, state, {
                    reqtokey: reqtokey,
                });
            }
            // This is the translation of the shortCode to a public key
            case 'TOKEY': {
                let tokey = state.tokey;
                tokey = action.tokey;
                return Object.assign({}, state, {
                    tokey: tokey,
                });
            }
            // This is the signed transaction to broadcast
            case 'BROADCAST': {
                let broadcast = state.broadcast;
                broadcast = action.broadcast;
                return Object.assign({}, state, {
                    broadcast: broadcast,
                });
            }
            // This is the txHash of the broadcasted transaction
            case 'TXHASH': {
                let txHash = state.txHash;
                txHash = action.txHash;
                return Object.assign({}, state, {
                    txHash: txHash,
                });
            }
            // This is the txHash of the broadcasted transaction
            case 'TXHASHITEM': {
                let txHashItem = state.txHashItem;
                txHashItem = action.txHashItem;
                return Object.assign({}, state, {
                    txHashItem: txHashItem,
                });
            }
            // This is the array containing all past transactions on user's publicKey
            case 'CONFIRMEDTX': {
                let confirmedTx = state.confirmedTx;
                confirmedTx = action.confirmedTx;
                return Object.assign({}, state, {
                    confirmedTx: confirmedTx,
                });
            }
            // This is the array containing all past transactions on user's publicKey
            case 'SHOWNTX': {
                let shownTx = state.shownTx;
                shownTx = action.shownTx;
                return Object.assign({}, state, {
                    shownTx: shownTx,
                });
            }
            // An array containing all reputation earned
            case 'REPUTATION': {
                let reputation = state.reputation;
                reputation = action.reputation;
                return Object.assign({}, state, {
                    reputation: reputation,
                });
            }
            // A base64 string containing the user avatar
            case 'AVATAR': {
                let avatar = state.avatar;
                avatar = action.avatar;
                return Object.assign({}, state, {
                    avatar: avatar,
                });
            }
            // An ipfsHash resolving to the user's base64 avatar
            case 'AVATARHASH': {
                let avatarHash = state.avatarHash;
                avatarHash = action.avatarHash;
                return Object.assign({}, state, {
                    avatarHash: avatarHash,
                });
            }
            // A string containing the username
            case 'USERNAME': {
                let username = state.username;
                username = action.username;
                return Object.assign({}, state, {
                    username: username,
                });
            }
            // A string containing the ipfs hash of an image
            case 'REQIPFS': {
                let reqipfs = state.reqipfs;
                reqipfs = action.reqipfs;
                return Object.assign({}, state, {
                    reqipfs: reqipfs,
                });
            }
            // A string containing an ipfs hash to resolve
            case 'IPFSHASH': {
                let ipfsHash = state.ipfsHash;
                ipfsHash = action.ipfsHash;
                return Object.assign({}, state, {
                    ipfsHash: ipfsHash,
                });
            }
            // A string containing the address of the recipient
            case 'TOADDRESS': {
                let toAddress = state.toAddress;
                toAddress = action.toAddress;
                return Object.assign({}, state, {
                    toAddress: toAddress,
                });
            }
            // A string containing the username of the recipient
            case 'TOUSERNAME': {
                let toUserName = state.toUserName;
                toUserName = action.toUserName;
                return Object.assign({}, state, {
                    toUserName: toUserName,
                });
            }
            // A string containing the amount to send
            case 'AMOUNTTOSEND': {
                let amountToSend = state.amountToSend;
                amountToSend = action.amountToSend;
                return Object.assign({}, state, {
                    amountToSend: amountToSend,
                });
            }
            // A string containing the budget for a new request
            case 'ITEMBUDGET': {
                let itemBudget = state.itemBudget;
                itemBudget = action.itemBudget;
                return Object.assign({}, state, {
                    itemBudget: itemBudget,
                });
            }
            // A string containing the description for a new request
            case 'ITEMDESCRIPTION': {
                let itemDescription = state.itemDescription;
                itemDescription = action.itemDescription;
                return Object.assign({}, state, {
                    itemDescription: itemDescription,
                });
            }
            // A string containing the hashtag fee
            case 'ITEMFEE': {
                let itemFee = state.itemFee;
                itemFee = action.itemFee;
                return Object.assign({}, state, {
                    itemFee: itemFee,
                });
            }
            // A string containing the hashtag fee
            case 'ITEMTOIPFS': {
                let itemToIpfs = state.itemToIpfs;
                itemToIpfs = action.itemToIpfs;
                return Object.assign({}, state, {
                    itemToIpfs: itemToIpfs,
                });
            }
            // The IPFS hash with the new request item data
            case 'ITEMDATAHASH': {
                let itemDataHash = state.itemDataHash;
                itemDataHash = action.itemDataHash;
                return Object.assign({}, state, {
                    itemDataHash: itemDataHash,
                });
            }
            // A signed tx to send
            case 'SENDSIGNEDTX': {
                let sendSignedTx = state.sendSignedTx;
                sendSignedTx = action.sendSignedTx;
                return Object.assign({}, state, {
                    sendSignedTx: sendSignedTx,
                });
            }
            // Hashtag will set the current hashtag we're on
            case 'HASHTAG': {
                let hashtag = state.hashtag;
                hashtag = action.hashtag;
                return Object.assign({}, state, {
                    hashtag: hashtag,
                });
            }
            // HashtagItem will set the current hashtag item we're on
            case 'HASHTAGITEM': {
                let hashtagItem = state.hashtagItem;
                hashtagItem = action.hashtagItem;
                return Object.assign({}, state, {
                    hashtagItem: hashtagItem,
                });
            }
            // replyRequest is a reply to be added to a hashtagItem
            case 'REPLYREQUEST': {
                let replyRequest = state.replyRequest;
                replyRequest = action.replyRequest;
                return Object.assign({}, state, {
                    replyRequest: replyRequest,
                });
            }
            // GeoHash is the full geohash of the user's location
            case 'GEOHASH': {
                let geohash = state.geohash;
                geohash = action.geohash;
                return Object.assign({}, state, {
                    geohash: geohash,
                });
            }
            // GeoHash is the new item's geohash
            case 'ITEMGEOHASH': {
                let itemGeohash = state.itemGeohash;
                itemGeohash = action.itemGeohash;
                return Object.assign({}, state, {
                    itemGeohash: itemGeohash,
                });
            }
            // userReputation is the reputation of a certain user
            case 'USERREPUTATION': {
                let userReputation = state.userReputation;
                userReputation = action.userReputation;
                return Object.assign({}, state, {
                    userReputation: userReputation,
                });
            }
            // selectProvider is the payload to select a provider from the list of replies
            case 'SELECTPROVIDER': {
                let selectProvider = state.selectProvider;
                selectProvider = action.selectProvider;
                return Object.assign({}, state, {
                    selectProvider: selectProvider,
                });
            }
        }
    };
    const store = Redux.createStore(reducer, /* preloadedState, */
        window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
    );
    ReduxMixin = new PolymerRedux(store);
</script>